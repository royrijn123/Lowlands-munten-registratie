<!DOCTYPE html>
<html lang="nl">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>NextDrink NFC</title>
  <style>
    /* ========== Basis layout ========== */
    html, body {
      height: 100%;
      margin: 0;
      padding: 0;
    }

    body {
      font-family: Arial, Helvetica, sans-serif;
      display: flex;
      justify-content: center;
      align-items: flex-start;
      background: linear-gradient(135deg, #7e22ce, #f97316);
      color: #fff;
    }

    .card {
      width: 100%;
      max-width: 420px;
      padding: 20px;
      box-sizing: border-box;
      border-radius: 14px;
      background: transparent;
      margin-top: 20px;
    }

    #logo {
      display: block;
      margin: 0 auto 16px;
      max-width: 150px;
      height: auto;
    }

    h1, h2, h3 { margin: 12px 0; }

    /* ========== Knoppen & grid ========== */
    .drinks-grid {
      display: grid;
      gap: 12px;
      grid-template-columns: repeat(2, 1fr); /* 2 naast elkaar */
    }

    button {
      border: none;
      border-radius: 14px;
      cursor: pointer;
      font-weight: 700;
      font-size: 18px;
      padding: 12px;
    }

    /* square buttons for drinks */
    .drinks-grid button {
      width: 100%;
      aspect-ratio: 1 / 1;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .primary {
      background: #7e22ce;
      color: #fff;
    }

    .secondary {
      background: #f97316;
      color: #fff;
    }

    /* Outline style used for "Tussenstand", "Terug" and "Ik wil afrekenen" */
    .outline {
      background: rgba(255,255,255,0.12);
      border: 1px solid rgba(255,255,255,0.22);
      color: #fff;
      width: 100%;
      padding: 14px;
      margin-top: 12px;
      border-radius: 10px;
      font-size: 16px;
      box-sizing: border-box;
    }

    .bestellijst-btn {
      background: #10b981;
      color: #fff;
      border-radius: 10px;
      padding: 14px;
      margin-top: 12px;
      width: 100%;
      font-weight: 700;
    }

    /* Loading overlay */
    #loadingOverlay {
      display: none;
      position: fixed;
      left: 0;
      top: 0;
      width: 100vw;
      height: 100vh;
      background: rgba(0,0,0,0.6);
      z-index: 9999;
      justify-content: center;
      align-items: center;
      flex-direction: column;
    }

    .spinner {
      width: 72px;
      height: 72px;
      border-radius: 50%;
      border: 8px solid rgba(255,255,255,0.25);
      border-top-color: #fff;
      animation: spin 1s linear infinite;
      margin-bottom: 12px;
    }

    @keyframes spin { from { transform: rotate(0); } to { transform: rotate(360deg); } }

    /* Lists */
    ul { text-align: left; padding-left: 20px; }
    .settle-ok { color: #a7f3d0; } /* green-ish */
    .settle-wait { color: #fef08a; } /* yellow-ish */

    /* small helper for final rows */
    .final-total { font-weight:700; margin-bottom:8px; }

    /* ensure clickable buttons don't overflow on small screens */
    @media (max-width: 420px) {
      .card { padding: 16px; }
      button { font-size: 16px; }
    }

  </style>
</head>
<body>
  <!-- Loading overlay -->
  <div id="loadingOverlay">
    <div class="spinner"></div>
    <div id="loadingText">Bezig met laden...</div>
  </div>

  <div class="card">
    <img id="logo" src="images/nextdrink-logo.png" alt="NextDrink Logo" />

    <!-- MENU -->
    <div id="menu" style="display:none;">
      <h2 id="menuTitle">Wat wil je dat ... voor je haalt?</h2>

      <div id="drinks" class="drinks-grid"></div>

      <button id="addDrinkBtn" class="outline" onclick="addCustomDrink()">+ Drankje toevoegen</button>
      <button id="bestelOverzichtBtn" class="bestellijst-btn" onclick="showBestellijst()">Bekijk bestellijst</button>
      <button id="scoresBtn" class="outline" onclick="showScores()">Bekijk tussenstand</button>
      <button id="finalBtn" class="outline" onclick="showFinal()">Eindafrekening</button>
    </div>

    <!-- CONFIRM -->
    <div id="confirm" style="display:none;">
      <h2>‚úÖ Verwerkt!</h2>
      <p id="confirmText"></p>
      <button class="secondary" onclick="newRound()">Nieuw rondje</button>
      <button class="outline" onclick="showScores()">Bekijk tussenstand</button>
      <button class="outline" onclick="showFinal()">Eindafrekening</button>
    </div>

    <!-- FIRST TIME -->
    <div id="firstTime" style="display:none;">
      <h2>Welkom!</h2>
      <p id="firstTimeText"></p>
      <button class="outline" onclick="renderMenuFromFirst()">Verder</button>
    </div>

    <!-- SCORES (tussenstand) -->
    <div id="scores" style="display:none;">
      <h2>Tussenstand</h2>
      <div id="scoreList"></div>
      <button class="outline" onclick="backToMenu()">Terug</button>
    </div>

    <!-- FINAL (eindafrekening) -->
    <div id="final" style="display:none;">
      <h2>üèÅ Eindafrekening</h2>
      <div id="finalTotals"></div>
      <div id="finalSettlements"></div>

      <div style="margin-top:12px;">
        <!-- 'Ik wil afrekenen' is outline style to match tussenstand/terug -->
        <button id="myPayBtn" class="outline" onclick="markMyPaid()">Ik wil afrekenen</button>
      </div>

      <div style="margin-top:12px;">
        <button class="outline" onclick="backToMenu()">Terug</button>
      </div>
    </div>

    <!-- BESTELLIJST -->
    <div id="bestellijst" style="display:none;">
      <h2>üìù Bestellijst</h2>
      <div id="bestellijstContent"></div>
      <button class="outline" onclick="backToMenu()">Terug</button>
    </div>
  </div>

  <script>
    /* ============================
       Config
       ============================ */
    const apiUrl = "https://script.google.com/macros/s/AKfycbyEp7DNokBvR75zhWqVukOWoNRewsSnVBzASFCN_fBLBA13xHAWMsP6Y-1sEj2IAn5tUA/exec";

    /* ============================
       State
       ============================ */
    let chipId = new URLSearchParams(window.location.search).get("chipId");
    if (!chipId) {
      alert("Geen chipId in URL!");
      throw new Error("Geen chipId");
    }

    let scannerName = localStorage.getItem("scannerName") || "";
    let chipOwner = ""; // loaded from server
    let drinks = [];
    let settlementPollInterval = null;

    /* ============================
       Helpers & UI utils
       ============================ */
    const $ = (id) => document.getElementById(id);

    function showLoading(show, text = "Bezig...") {
      $("loadingText").textContent = text;
      $("loadingOverlay").style.display = show ? "flex" : "none";
      // disable buttons when loading
      document.querySelectorAll("button").forEach(b => b.disabled = show);
    }

    function hideAll() {
      ["menu","confirm","scores","final","firstTime","bestellijst"].forEach(id => {
        const el = $(id);
        if (el) el.style.display = "none";
      });
    }

    /* ============================
       Init logic: single name prompt rules
       ============================ */
    async function init() {
      showLoading(true, "Initialiseren...");

      try {
        // 1) Get chip owner from server
        const ownerResp = await fetch(`${apiUrl}?action=getOwner&chipId=${encodeURIComponent(chipId)}`);
        chipOwner = (await ownerResp.text()).trim();

        // Cases:
        // A) scannerName empty && chipOwner empty  -> ask once -> set both (localStorage + setOwner)
        // B) scannerName empty && chipOwner exists -> ask scannerName only -> set localStorage
        // C) scannerName exists && chipOwner empty -> ask chipOwner only -> setOwner only (do not overwrite scannerName)
        // D) both exist -> nothing to ask

        if (!scannerName && !chipOwner) {
          // Ask once for both
          const name = prompt("Wat is jouw naam?")?.trim();
          if (!name) {
            alert("Geen naam ingevoerd. Stop.");
            showLoading(false);
            return;
          }
          scannerName = name;
          chipOwner = name;

          localStorage.setItem("scannerName", scannerName);

          // send to server to set owner for this chip
          await fetch(apiUrl, {
            method: "POST",
            body: new URLSearchParams({ action: "setOwner", chipId, owner: chipOwner })
          });

          $("firstTimeText").innerHTML = `Welkom ${chipOwner}!<br/>Plak nu de NFC sticker op je telefoon en laat deze scannen als jij een rondje haalt.`;
          hideAll();
          $("firstTime").style.display = "block";
          showLoading(false);
          return;
        }

        if (!scannerName && chipOwner) {
          // ask only for scannerName
          const name = prompt("Wat is jouw naam?")?.trim();
          if (!name) {
            scannerName = "Onbekend";
          } else {
            scannerName = name;
          }
          localStorage.setItem("scannerName", scannerName);
        }

        if (scannerName && !chipOwner) {
          // ask only for chip owner; do not overwrite scannerName
          const name = prompt("Wat is jouw naam?")?.trim();
          if (!name) {
            alert("Geen naam ingevoerd voor chip-eigenaar. Stop.");
            showLoading(false);
            return;
          }
          chipOwner = name;
          await fetch(apiUrl, {
            method: "POST",
            body: new URLSearchParams({ action: "setOwner", chipId, owner: chipOwner })
          });

          $("firstTimeText").innerHTML = `Welkom ${chipOwner}!<br/>Plak nu de NFC sticker op je telefoon en laat deze scannen als jij een rondje haalt.`;
          hideAll();
          $("firstTime").style.display = "block";
          showLoading(false);
          return;
        }

        // If we reach here both exist: load drinks and show menu
        await loadDrinks();
        renderMenu();

      } catch (err) {
        console.error(err);
        alert("Fout bij initialiseren.");
      } finally {
        showLoading(false);
      }
    }

    function renderMenuFromFirst() {
      // called when user clicks 'Verder' on firstTime screen
      loadDrinks().then(renderMenu);
    }

    /* ============================
       Drinks management
       ============================ */
    async function loadDrinks() {
      try {
        const resp = await fetch(`${apiUrl}?action=getDrinks`);
        drinks = await resp.json();
      } catch (e) {
        console.warn("Fout bij ophalen drankjes, gebruik default lijst", e);
        drinks = [
          { name: "Kleine bier", price: 4.40 },
          { name: "Grote bier", price: 8.00 },
          { name: "Desperados", price: 6.50 },
          { name: "Wijn", price: 6.00 },
          { name: "0.0 bier", price: 4.00 },
          { name: "Frisdrank", price: 4.00 }
        ];
      }
    }

    async function saveDrinks() {
      try {
        await fetch(apiUrl, {
          method: "POST",
          body: new URLSearchParams({ action: "setDrinks", drinks: JSON.stringify(drinks) })
        });
      } catch (e) {
        console.error("Fout bij opslaan drankjes", e);
      }
    }

    /* ============================
       Render menu / place order
       ============================ */
    function renderMenu() {
      hideAll();
      $("menuTitle").textContent = `Wat wil je dat ${chipOwner} voor je haalt?`;

      const div = $("drinks");
      div.innerHTML = "";

      drinks.forEach(d => {
        const btn = document.createElement("button");
        btn.className = "secondary";
        btn.textContent = d.name;
        btn.onclick = () => placeOrder(d);
        div.appendChild(btn);
      });

      $("menu").style.display = "block";
    }

    async function addCustomDrink() {
      const name = prompt("Naam van het nieuwe drankje?");
      if (!name) return;
      const priceStr = prompt(`Prijs van "${name}"? (‚Ç¨)`);
      if (!priceStr) return;
      const price = parseFloat(String(priceStr).replace(",", "."));
      if (isNaN(price) || price <= 0) return alert("Ongeldige prijs!");
      drinks.push({ name: name.trim(), price });
      await saveDrinks();
      renderMenu();
    }

    async function placeOrder(drink) {
      showLoading(true, "Verwerken...");
      try {
        await fetch(apiUrl, {
          method: "POST",
          body: new URLSearchParams({
            action: "addScan",
            chipId,
            scanner: scannerName,
            drink: drink.name,
            amount: drink.price
          })
        });

        hideAll();
        $("confirmText").textContent = `${drink.name} (‚Ç¨${drink.price}) is doorgegeven aan ${chipOwner}.`;
        $("confirm").style.display = "block";

      } catch (err) {
        console.error(err);
        alert("Fout bij plaatsen order.");
      } finally {
        showLoading(false);
      }
    }

    /* ============================
       Bestellijst (laatste 15 minuten voor chipOwner)
       ============================ */
    async function showBestellijst() {
      showLoading(true, "Bestellijst laden...");
      try {
        const resp = await fetch(`${apiUrl}?action=getScans`);
        const scans = await resp.json();

        const now = Date.now();
        const FIFTEEN_MIN = 15 * 60 * 1000;

        const recent = scans.filter(s => {
          return s.owner === chipOwner && (now - new Date(s.timestamp).getTime() <= FIFTEEN_MIN);
        });

        const grouped = {};
        recent.forEach(s => {
          if (!grouped[s.scanner]) grouped[s.scanner] = [];
          grouped[s.scanner].push(s.drink);
        });

        let html = `<p><strong>${chipOwner}</strong> gaat deze drankjes halen:</p><ul>`;
        for (const [scanner, drinksList] of Object.entries(grouped)) {
          html += `<li><strong>${scanner}</strong>: ${drinksList.join(", ")}</li>`;
        }
        html += "</ul>";
        html += `<p style="margin-top:10px;font-size:0.9em;opacity:0.8;">(Laatste 15 minuten)</p>`;

        hideAll();
        $("bestellijstContent").innerHTML = html;
        $("bestellijst").style.display = "block";

      } catch (err) {
        console.error(err);
        alert("Fout bij laden bestellijst.");
      } finally {
        showLoading(false);
      }
    }

    /* ============================
       Tussenstand (rondes per chipowner)
       - Ronde: alle scans *ontvangen door chipOwner* binnen 15-min window
       ============================ */
    async function showScores() {
      showLoading(true, "Tussenstand laden...");
      try {
        const resp = await fetch(`${apiUrl}?action=getScans`);
        const scans = await resp.json();

        const FIFTEEN_MIN = 15 * 60 * 1000;
        const roundsByOwner = {};

        // collect timestamps per owner (owner = chipOwner)
        scans.forEach(s => {
          const owner = s.owner;
          const ts = new Date(s.timestamp).getTime();
          if (!roundsByOwner[owner]) roundsByOwner[owner] = [];
          roundsByOwner[owner].push(ts);
        });

        // count rounds: sort times and count start of new round when gap > 15min
        const results = [];
        for (const [owner, times] of Object.entries(roundsByOwner)) {
          const sorted = times.sort((a,b) => a - b);
          let rounds = 0;
          let last = -Infinity;
          for (const t of sorted) {
            if (t - last > FIFTEEN_MIN) {
              rounds += 1;
              last = t;
            } else {
              last = Math.max(last, t);
            }
          }
          results.push({ owner, rounds });
        }

        // sort descending by rounds
        results.sort((a,b) => b.rounds - a.rounds);

        let html = "<ul>";
        if (results.length === 0) html += "<li>Nog geen data</li>";
        else {
          results.forEach(r => {
            html += `<li><strong>${r.owner}</strong> ‚Äî ${r.rounds} rondje${r.rounds === 1 ? "" : "s"} gehaald</li>`;
          });
        }
        html += "</ul>";

        hideAll();
        $("scoreList").innerHTML = html;
        $("scores").style.display = "block";

      } catch (err) {
        console.error(err);
        alert("Fout bij laden tussenstand.");
      } finally {
        showLoading(false);
      }
    }

    /* ============================
       Eindafrekening
       - toont totaalbedrag per persoon
       - genereert lijst "wie betaalt aan wie en hoeveel"
       - 'Ik wil afrekenen' knop voor gebruiker om zichzelf te markeren
       - toont status van wie heeft gedrukt (central via getSettlement if available)
       ============================ */
    async function showFinal() {
      showLoading(true, "Eindafrekening laden...");
      try {
        // get final calculation
        const resp = await fetch(`${apiUrl}?action=getFinal`);
        const finalData = await resp.json();
        // finalData: { result: [{name, balance}], settlements: [{from,to,amount}] }

        const totals = finalData.result || [];
        const settlements = finalData.settlements || [];

        // build totals HTML
        let htmlTotals = "";
        if (!totals.length) {
          htmlTotals = "<p>Nog geen data</p>";
        } else {
          totals.sort((a,b)=> b.balance - a.balance);
          htmlTotals += '<div class="final-total">Totaal uitgegeven per persoon:</div>';
          htmlTotals += "<ul>";
          totals.forEach(t => {
            const bal = Number(t.balance).toFixed(2);
            htmlTotals += `<li><strong>${t.name}</strong> ‚Äî ‚Ç¨${bal} (${Number(t.balance)>=0 ? 'positief' : 'negatief'})</li>`;
          });
          htmlTotals += "</ul>";
        }

        // build settlement HTML (wie betaalt aan wie)
        let htmlSettle = "";
        if (!settlements.length) {
          htmlSettle = "<p>Geen verrekeningen nodig.</p>";
        } else {
          htmlSettle += '<div style="margin-top:8px;font-weight:700;">Verrekeningen</div>';
          htmlSettle += "<ul>";
          settlements.forEach(s => {
            htmlSettle += `<li>${s.from} betaalt ‚Ç¨${Number(s.amount).toFixed(2)} aan ${s.to}</li>`;
          });
          htmlSettle += "</ul>";
        }

        hideAll();

        $("finalTotals").innerHTML = htmlTotals;
        $("finalSettlements").innerHTML = htmlSettle;

        // Start polling settlement-status (who clicked "ik wil afrekenen") if endpoint exists
        startSettlementPolling();

        $("final").style.display = "block";

      } catch (err) {
        console.error(err);
        alert("Fout bij laden eindafrekening.");
      } finally {
        showLoading(false);
      }
    }

    /* ============================
       Settlement / 'Ik wil afrekenen' handling
       - markMyPaid -> POST markAsPaid with name=scannerName
       - startSettlementPolling -> tries to fetch a 'getSettlement' endpoint,
         if present it parses who has paid. Falls back to nothing.
       ============================ */

    async function markMyPaid() {
      showLoading(true, "Bezig met bevestigen...");
      try {
        await fetch(apiUrl, {
          method: "POST",
          body: new URLSearchParams({ action: "markAsPaid", name: scannerName })
        });
        // immediate UI update (optimistic)
        await pollSettlementOnce();
      } catch (err) {
        console.error(err);
        alert("Fout bij registreren 'Ik wil afrekenen'.");
      } finally {
        showLoading(false);
      }
    }

    // Poll once (tried) for settlement data (who clicked)
    async function pollSettlementOnce() {
      try {
        const resp = await fetch(`${apiUrl}?action=getSettlement`);
        if (!resp.ok) return; // endpoint not available - nothing to do
        const items = await resp.json(); // expect [{timestamp,chipOwner,scanner,paid}, ...] or [{name,hasPaid}]
        renderSettlementStatus(items);
      } catch (err) {
        // ignore if endpoint doesn't exist or fails
        // console.info("getSettlement not available:", err);
      }
    }

    // periodic poll
    function startSettlementPolling() {
      // clear existing
      if (settlementPollInterval) clearInterval(settlementPollInterval);

      // do an immediate poll, then every 3s
      pollSettlementOnce();
      settlementPollInterval = setInterval(pollSettlementOnce, 3000);
    }

    // render settlement status if we got a settlement array
    function renderSettlementStatus(items) {
      // normalize items to map name->paid
      const map = {};
      if (!items || !Array.isArray(items)) return;
      items.forEach(it => {
        // support formats: {name, hasPaid} or {chipOwner, scanner, paid}
        if (it.name !== undefined && it.hasPaid !== undefined) {
          map[it.name] = !!it.hasPaid;
        } else if (it.scanner !== undefined && it.paid !== undefined) {
          map[it.scanner] = !!it.paid;
        } else if (it.scanner && it.paid === true) {
          map[it.scanner] = true;
        }
      });

      // update DOM: add a block under finalSettlements showing who clicked
      let html = "<div style='margin-top:10px;font-weight:700;'>Bevestigingen</div><ul>";
      for (const [name, paid] of Object.entries(map)) {
        html += `<li>${name} ‚Äî ${paid ? '<span class="settle-ok">‚úÖ bevestigd</span>' : '<span class="settle-wait">‚è≥ nog niet'}</span></li>`;
      }
      html += "</ul>";

      // put after the settlements block
      const target = $("finalSettlements");
      if (target) {
        target.insertAdjacentHTML("afterend", html);
      }
    }

    /* ============================
       Navigation helpers
       ============================ */
    function backToMenu() {
      if (settlementPollInterval) {
        clearInterval(settlementPollInterval);
        settlementPollInterval = null;
      }
      renderMenu();
    }

    function newRound() {
      renderMenu();
    }

    /* ============================
       Start
       ============================ */
    init();

    // expose some functions to global for potential inline onclick use
    window.showBestellijst = showBestellijst;
    window.showScores = showScores;
    window.showFinal = showFinal;
    window.addCustomDrink = addCustomDrink;
    window.newRound = newRound;
    window.backToMenu = backToMenu;
    window.markMyPaid = markMyPaid;
    window.renderMenuFromFirst = renderMenuFromFirst;

  </script>
</body>
</html>
